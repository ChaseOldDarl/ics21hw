1.The First Homework:

2.61
A   !(x+1)
B   !x
C   !((~x)<<((sizeof(int)<<3)-8))
D   !(x>>((sizeof(int)<<3)-8))

2.62
int int_shifts_are_arithmetic()
{
	int a=-1;
	a=a>>1;
	if(a==-1)
		return 1;
	else
		return 0;
}

2.65
/*Return 1 when x contains an odd number of 1s; 0 otherwise.
  Assume w=32 */
int odd_ones(unsigned x)
{
	x=x^(x>>16);
	x=x^(x>>8);
	x=x^(x>>4);
	x=x^(x>>2);
	x=x^(x>>1);
	return x&1;
}


### 第一次作业反馈

第一题：正确  
第二题：正确  
第三题：正确  


第二次作业 2.88 208 011101010 208 -7/1024 100000111 -7/1024 5/(2^17) 000000000 0 -4096 111110000 -inf 768 011110000 +inf
2.92 /Compute -f. If f is NaN, then return f./ float_bits float_negate(float_bits f) { unsigned exp=(f>>23)&0xff; unsigned frac=f&0x7fffff; if(exp==0xff&&(!(frac^0==0))) return f; else return f^0x80000000; }
2.96 /*Compute (int)f. *If conversion causes overflow or f is NaN, return 0x80000000 */ int float_f2i(float_bits f) { int result; unsigned sign=(f>>31)&1; unsigned exp=(f>>23)&0xff; unsigned frac=f&0x7fffff; if(exp==0xff)//inf or NaN return 0x80000000; else if(exp==0)//too small return 0; else if(exp>157)//overflow return 0x80000000; else if(exp<=126)//smaller than 1 return 0; else if(exp>=150)//must be an interger, no need of rounding { int bitoffrac; for(int i=0;i<23;i++) { bitoffrac=(frac>>i)&1; if(bitoffrac==1) result+=(1<<(exp-150+i)); } result+=(1<<(exp-127)); if(sign==0) return result; else return (~result)+1; } else//needs rounding to zero { result+=(1<<(exp-127)); frac<<=9; int bitoffrac; for(int i=0;i<exp-127;i++) { bitoffrac=frac&0x80000000; for(int i=0;i<exp-127;i++) { if(bitoffrac==1) result+=(1<<(exp-i-128)); } frac<<=1; } if(sign==0) return result; else return ((~result)+1); } }
