
17/9/17 HW1

2.61
A !(x ^ ~0)
B !(x ^ 0)
C !((x & 0xFF) ^ 0xFF)
D !(x >> ((sizeof(int) - 1) << 3) ^ 0)

2.62
bool int_shifts_are_arithmetic() {
	int x = 0;  //需要int型x
	return !((~x >> 1) ^ ~x); //通过对右移后首位进行判断
}

2.65
int odd_ones(unsigned x) {
	x ^= (x >> 16); //对比前一半和后一半，异或得到的1的个数的奇偶性与原数的1的个数的奇偶性相同
	x ^= (x >> 8);
	x ^= (x >> 4);
	x ^= (x >> 2);
	x ^= (x >> 1);
	return x & 1;
}


### 第一次作业反馈

第一题：正确  
第二题：正确  
第三题：正确  

17/9/23 HW2

2.88
A						B
1 01110 001		-9/16			1 0110 0010		-9/16
0 10110 101		208			0 1110 1010		208
1 00111 110		-7/1024			1 0000 0111		-7/1024
0 00000 101		5/2^17			0 0000 0001		1/2^10
1 11011 000		-2^12			1 1110 1111		-248
0 11000 100		768			0 1111 0000		正无穷 

2.92
float_bite float_negate(float_bite f) {
	if ((f & 0x7fffffff) > 0x7f800000) { //NaN直接返回f 
		return f;
	}
	else { //否则均将符号位取反返回 
		return f ^ 0x80000000;
	}
}

2.96
int float_f2i(float_bite f) {
	unsigned signal = f & 0x80000000;
	unsigned exp = (f >> 23) & 0xff - 0x7f;
	unsigned res = f & 0x7fffff + 0x800000;
	if (exp > 31) return 0x80000000; //如果指数大于31，必然溢出，返回0x80000000 
	else if (exp < -1) return 0; //如果指数小于-1，必然舍入到0，返回0 
	else if (exp >= 23) { //如果指数在23到31之间，只需把res（frac）部分左移若干位即可 
		res = res << (exp - 23);
	}
	else {
		unsigned fg = 1;
		int n = 22 - exp;
		for (int i = 0; i < n; i++) fg = fg << 1 + 1; //制造长度为n = 23 - exp的都为1的串，用来取出需要舍入的若干位 
		unsigned rounding = (res & fg) > (1 << n); //判断舍入时，取出若干位，大于一半直接进位 
		if (!((res & (fg << 1 + 1)) ^ (3 << n))) rounding = 1; //如果恰好一半且末位为1，需要进位 
		res = res >> (n + 1);
		if (rounding) res = res + 1;
	}
	if (signal == 0) return res;
	else return -res; //符号位为1时返回相反数 
}

### 第二次作业反馈

第一题：正确  
第二题：正确  
第三题：有误  
