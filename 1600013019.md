//homework1
//2.61
A.!(x^-1)
B.!(x^0)
C.!((x&0xff)^0xff)
D.!(x>>(sizeof(int)*8-8))

//2.62
int int_shifts_are_arithmetic()
{
	int x=-1>>(sizeof(int)*8-1);//log:x=1,ari:x=-1
	if(!(x^1))return 0;
	else return 1;
}

//2.65
int odd_ones(unsigned x)
{
	x^=x>>16;
	x^=x>>8;
	x^=x>>4;
	x^=x>>2;
	x^=x>>1;
	return x%2;
}

### 第一次作业反馈

第一题：A、B正确，C、D有误  
第二题：有误  
第三题：正确  


//homework2
//2.88
208  011101010 208
-7/1024  100000111  -7/1024
5/(2^17)  000000000  0
-2^12  111110000  负无穷
768  011110000  正无穷

//2.92
float_bits float_negate(float_bits f)
{
	unsigned sign=f>>31;
	unsigned exp=f>>23&0xff;
	unsigned frac=f&0x7fffff;
	if(exp==0xff)
		return f;
	else
		return ((!sign)<<31)|(exp<<23)|frac;
}

//2.95
int float_f2i(float_bits f)
{
	const int bias=127;
	int sign=f>>31;
	int exp=((f>>23)&0xff)-bias;//2的指数位
	int frac=f&0x7fffff+(1<<23);//加上前导1之后的完整的小数部分
	int ans;
	if(exp>30)//int最大是2^31-1,最多可以往左移30位，大于30就out of range
		return 0x80000000;
	else if(exp>23)//保证位运算的位数是正数
		ans=frac<<(exp-23);//实质是先向右移23位再向左移exp，防止丢失数据
	else 
		ans=frac>>(23-exp);
	if(sign==1)
		return -ans;
	else return ans;
}

### 第二次作业反馈
 
第一题：有1个错误  
第二题：有误  
第三题：正确  
 
