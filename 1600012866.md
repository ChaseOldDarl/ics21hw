### homework1（已改正）
#### Ex2.61

```c
a = !(x + 1);
b = !x;
c = !((x & 0xff) ^ 0xff);
d = !(x >> ((sizeof(int) - 1) << 3) & 0xff);
// 暴力做法，每一次都假定x满足要求，然后把对应bit转化为0
```

#### Ex2.62

```c
bool int_shifts_are_arithmetic(){
	return !!((-1 >> 1) ^ INT_MAX);
	// 逻辑右移的情况下，-1>>1是INT_MAX，与自身进行Xor操作得0
}
```

#### Ex2.65

```c
/* Return 1 when x contains an odd number of 1s; 0 otherwise.
   Assume w=32. The function cantains less than 12 operations. */
int odd_ones(unsigned x){
	x ^= (x >> 16);
	x ^= (x >> 8);
	x ^= (x >> 4);
	x ^= (x >> 2);
	x ^= (x >> 1);
	return x & 1;
	// 由于Xor操作的性质，不会改变操作数的奇偶性
	// 用二分方法，每一次操作都把高(len/2)位的奇偶性加载到低(len/2)上
}
```

### 第一次作业反馈

第一题：A有一点小问题，其他正确  
第二题：有误  
第三题：正确

### homework2

#### Ex2.88

第一行：208、0 1100 1110、208

第二行：-7/1024、1 0000 0111、-7/1024

第三行：5/131072、0 0000 0001、1/1024

第四行：-4096、1 1110 1111、-248

第五行：768、0 1111 0000、+INF

#### Ex2.92

```C
float_bits float_negate(float_bits f){
    int exp = (f >> 23) & 0xff;
    int frac = f & 0x7fffff;
    if (!(exp ^ 0xff) && frac){
        return f;
    }
    return f ^ (1 << 31);
}
```

#### Ex2.96

```c
int float_f2i(float_bits f){
    int sign = (f >> 31) & 1;
    int exp = (f >> 23) & 0xff - 127; // 计算2的幂指数部分
    if (exp >= 31){
        return 0x80000000;
    }else if (exp < 0){
        return 0;
    }
    int frac = f & 0x7fffff + 0x800000; // 将尾数加上隐藏的1
    if (exp >= 23){
        if (sign)
            return -(frac << (exp - 23));
        else
            return (frac << (exp - 23));
    }else{
        if (sign)
            return -(frac >> (23 - exp)); //直接右移可以达到向0取整的目的
        else
            return (frac >> (exp - 23));
    }
}
```

